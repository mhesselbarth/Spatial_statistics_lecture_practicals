---
title: 'Spatial statistics'	
author: 'Kerstin Wiegand, Craig Simpkins, Maximilian Hesselbarth'	
date: 'Summer semester 2018'	
output: html_document
editor_options: 
  chunk_output_type: console
---
# Practical 2b

First, we load all needed packages, just as before.

```{r, message = FALSE}
  library(spatstat)
  library(tidyverse)
```

## Exercise 5 
__Task:__ Calculate the bivariate g12 function using the null model random labeling. Was the process that labeled trees as dead or alive a random process. 

In case it is not in our workspace anymore, we import the data and convert it to a `ppp` object again.

```{r, message = FALSE}
  setwd('C:/Users/Maximilian/ownCloud/03_Lehre/Spatial_Statistics/Practicals/Spatial_statistics_R')
  douglas_fir <- read_delim(file = 'DouglasFir_LiveDead_OGN.txt', delim = ';')
  
  douglas_fir <- mutate(douglas_fir,
                        mark = case_when(mark == 1 ~ 'alive',
                                         mark == 2 ~ 'dead'),
                        mark = as.factor(mark))
  
  plot_area <- ripras(x = douglas_fir$x, y = douglas_fir$y, shape = 'rectangle')
  douglas_fir_ppp <- as.ppp(X = douglas_fir, W = plot_area)
```

The same goes for the O-ring statistic.

```{r}
  Oest <- function(input, correction = 'Ripley', r = NULL, ...){
    p_fct <- pcf(input, correction = correction, r = r, divisor = 'd')
    lambda <- intensity(unmark(input))
    eval.fv(p_fct*lambda)
  }
```

The function `envelope()` can also be used to simulate more complex null models than _CSR_ and basically all functions (`fun`) that return a `fv` object. This time, we use the bivariate pair-correlation function as `fun` called `pcfcross` in `spatstat`. We need to specify the arguments of `pcfcross` `i` and `j` indicating the two types of marks. `simulate` allows us to specify any possible null model as an expression. Random labeling can be simulated with the help of `rlabel`. Lastly, we specify the number of simulation (`nsim`) and the highest/lowest values to use for the envelopes (`nrank`) and the distances at which the function should be evaluated (`r`) just as before.

```{r, message = FALSE, warning = FALSE, results = 'hide'}
  simulaion_envelope_random_labeling <- envelope(douglas_fir_ppp, fun = pcfcross, i = 'alive', j = 'dead', 
                                                 r = seq(from = 0, to = 45, by = 0.5),
                                                 divisor = 'd', nsim = 199, nrank = 5,
                                                 simulate = expression(rlabel(douglas_fir_ppp)))
```

```{r, echo = FALSE,  fig.align = 'center'}
  plot(simulaion_envelope_random_labeling, xlim = c(0,45), 
       main = 'Bivariate pair correlation function\nrandom labelling', legend = FALSE)
```

## Exercise 6
__Task:__ Can the small-scale regularity in the live Douglas fir trees be modeled by a hard-core process? What about a soft-core process?

We can use `rStrauss()` to simulate hardcore- and softcore processes. Firstly, we subset the data using only living trees. Then, we simulate the hardcore process. We want the same intensity as the observed data (`beta`). `R` is the interaction distance between the points and `gamma` is the probability of two points being separated by distances < `R`. Therefore, setting this argument to 0 leads to a hardcore process. Lastly, we need to specify the number of (`nsim`) and the observation window (`W`, same as observed data) of the simulated patterns.

```{r}
  alive <- subset.ppp(douglas_fir_ppp, marks == 'alive', drop = T)
  
  simulated_patterns_hardcore <-rStrauss(beta = intensity(alive),
                                         R = 1, gamma = 0, 
                                         nsim = 199, W = alive$window)
```

The result is a list of simulated point patterns, that can be used as the `simulate` argument of the `envelope()` function. Now, the function calculates the summary function for each pattern in the list and computes the envelopes based on the results.

```{r, message=FALSE, warning=FALSE, results = 'hide'}
  envelope_hardcore <- envelope(Y = alive, fun = Oest, 
                                r = seq(from = 0, to = 45, by = 0.5),
                                nsim = 199, nrank = 5,
                                simulate = simulated_patterns_hardcore)
```

The softcore process is very similar, with the only difference that the probability `gamma` of two points being separated by distance `R` is increased.

```{r, message=FALSE, warning=FALSE, results = 'hide'}
  simulated_patterns_softcore <- rStrauss(beta = intensity(alive),
                                          R = 1, gamma = 0.3, 
                                          nsim = 199, W = alive$window)

  envelope_softcore <- envelope(alive, fun = Oest,
                                r = seq(from = 0, to = 45, by = 0.5),
                                nsim = 199, nrank = 5,
                                simulate = simulated_patterns_softcore)
```

```{r, echo = FALSE,  fig.align = 'center'}
  # par(mfrow=c(1,2))
  plot(envelope_hardcore, xlim=c(0,45), 
       main = "Univariate O-ring statistic\nhard-core process", legend = FALSE)
      
  plot(envelope_softcore,xlim=c(0,45), 
       main = "Univariate O-ring statistic\nsoft-core process", legend = FALSE)
  # par(mfrow=c(1,1))
```

## Exercise 7 
__Task:__ Now use the data set 'DouglasFir_Adult_vs_Seedling_OG-N.txt'. Here, pattern 1 gives the locations of adult trees and pattern 2 gives the locations of seedlings. Calculate O12(r) and generate 95% confidence envelopes for the null model 'Pattern 1 fixed, pattern 2 random' (antecedent conditions). What would be a meaningful interpretation of the results?

Firstly, we import the data and convert it to a `ppp` object. Also, we reclassify the mark column to 1 == 'adults' and 2 == 'seedlings' and convert is as a factor. 

```{r}
  setwd('C:/Users/Maximilian/ownCloud/03_Lehre/Spatial_Statistics/Practicals/Spatial_statistics_R')
  douglas_fir <- read_delim(file = 'DouglasFir_Adult_vs_Seedling_OG-N.txt', delim = ';')
  
  douglas_fir <- mutate(douglas_fir,
                        mark = case_when(mark == 1 ~ 'adults',
                                         mark == 2 ~ 'seedlings'),
                        mark = as.factor(mark))
  
  plot_area <- ripras(x = douglas_fir$x, y = douglas_fir$y, shape = 'rectangle')
  douglas_fir_ppp <- as.ppp(X = douglas_fir, W = plot_area)
```

```{r, echo = FALSE, fig.align = 'center'}
  plot(douglas_fir_ppp, main = "Douglas fir")
```

Now, we need to implement the bivariate O-ring statistic O12(r). We want to multiply the bivariate pair-correlation function g12(r) with the intensity of lambda2.

```{r}
Oestcross <- function(input,i,j, correction = 'Ripley', r = NULL, ......){
  gij <- pcfcross(input, 
                  i = i, j = j, r = r,
                  correction = correction, divisor = "d")
  lambda <- intensity(input)[j]
  eval.fv(gij * lambda)
}
```

`spatstat` has no build-in function to simulate a null model of _antecedent conditions_. But remember, we can give the `simulate` argument of the `envelope()` function a list of patterns. Therefore, we just need to simulate the null model and save the results in a list. 

After splitting the point pattern into seedlings and adults, we create a new, random pattern with the same number of points (`n`) and the same observation window (`win`) as the seedlings. Then, we superimpose the random seedlings with the unchanged adults. Lastly, we save the result in a list.

```{r}
null_model_pattern <- list()

for(i in 1:199){
  seedlings <- subset.ppp(douglas_fir_ppp, marks == "seedlings", drop = TRUE)
  adults <- subset(douglas_fir_ppp, marks == "adults", drop = TRUE)
  
  random_seedlings <- rpoint(n = seedlings$n,
                             win = seedlings$window)
  
  overall_pattern <-  superimpose(adults = unmark(adults),
                                  seedlings = random_seedlings)
  
  null_model_pattern[i] <- list(overall_pattern )
}
```
Now, we can compute the simulation envelopes as usually.

```{r,  message = FALSE, warning = FALSE, results = 'hide'}
  antecedent_conditions <- envelope(douglas_fir_ppp, fun = Oestcross, 
                                    i = "adults", j = "seedlings",
                                    r = seq(from = 0, to = 45, by = 0.5),
                                    nsim = 199,  nrank = 5,
                                    simulate = null_model_pattern)
```

```{r, echo = FALSE, fig.align = 'center'}
  plot(antecedent_conditions, xlim = c(0, 45),
       main = "Bivariate O-ring statistic\nantecedent conditions", legend = FALSE)
```

## Exercise 8
__Task:__ How does the interpretation of the 'Toroidal shift' null model differ from the null models in 7)? What is the advantage? Is it always an advantage?

There is a possibility to simulate the toroidal shift null model with functions provided by `spatstat`. We just use the function `rshift()` and specify the behavior at the edge of the observation area (`edge`) and which points should be shifted (`which`).

```{r, message = FALSE, warning = FALSE, results = 'hide'}
  trdl.shft <- envelope(douglas_fir_ppp, fun = Oestcross, 
                        i = "adults", j = "seedlings",
                        r = seq(from = 0, to = 45, by = 0.5),
                        nsim = 199, nrank = 5,
                        simulate = expression(rshift(douglas_fir_ppp, which = "seedlings", edge="torus")))
```
```{r, echo = FALSE, fig.align = 'center'}
  plot(trdl.shft, xlim = c(0, 45), 
       main = "Bivariate O-ring statistic\ntoroidal shift",  legend = FALSE)
```

__References__:

Baddeley, A., Rubak, E., Turner, R., 2015. Spatial point patterns: Methodology and applications with R. Chapman and Hall/CRC Press, London.

Getzin, S., Dean, C., He, F., Trofymow, J.A., Wiegand, K., Wiegand, T., 2006. Spatial patterns and competition of tree species in a Douglas fir chronosequence on Vancouver Island. Ecography (Cop.). 29, 671–682.

Getzin, S., Wiegand, T., Wiegand, K., He, F., 2008. Heterogeneity influences spatial patterns and demographics in forest stands. J. Ecol. 96, 807–820.
