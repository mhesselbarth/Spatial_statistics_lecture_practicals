---
title: "Cluster processes / Mark correlation function / Heterogenous conditions"
author: "Wiegand, Simpkins, Hesselbarth"
date: "Summer semester 2019"
output: 
  html_document:
    theme: cosmo
editor_options: 
  chunk_output_type: console
---

```{r s_3_logo, echo = FALSE, fig.align = "center"}
knitr::include_graphics("logo.png", auto_pdf = FALSE)
```

As always, we load all needed packages.

```{r s_3_libraries, message = FALSE}
  library(spatstat)
  library(tidyverse)
```

# Cluster process

### Exercise 1 
__Task:__ Perform a point-pattern analysis on the *Hemlock_Adults_vs_SmallSaps.txt* data set using 'CSR' as null model. We are now especially interested in pattern 2, the small saplings. Using a cell size of 1 meter, calculate the O22(r). Up to which scale do we find significant clustering of the saplings?

We import the data first and convert it as `ppp`. Also, we reclassify the marks as 1 == 'adults' and 2 == 'saplings'.

```{r s_3_import_data, message = FALSE, collapse = TRUE}
  hemlock <- read_delim(file = "Data/Hemlock_Adults_vs_SmallSaps.txt", 
                        delim = ";")
  
  hemlock <- mutate(hemlock,
                    mark = case_when(mark == 1 ~ "adults",
                                     mark == 2 ~ "saplings"),
                    mark = as.factor(mark))
  
  plot_area <- ripras(x = hemlock$x, y = hemlock$y, shape = "rectangle")
  
  hemlock_ppp <- as.ppp(X = hemlock, W = plot_area)
  
  summary(hemlock_ppp)
```

```{r s_3_plot_data, echo = FALSE, fig.align = "center"}
  plot(hemlock_ppp, main = "Hemlock")
```

Then, we implement the O-ring statistic.

```{r s_3_define_fun}
  Oest <- function(input, r = NULL, 
                   correction = "Ripley", divisor = "d", ...){
    
    p_fct <- pcf(input, r = r,
                 correction = correction, 
                 divisor = divisor)
    
    lambda <- intensity(unmark(input))
    
    eval.fv(p_fct*lambda)
  }
```

We are just interested in the saplings, therefore we subset them first. Then we calculate the O-ring statistic with simulation envelopes and 'CSR' as null model.

```{r s_3_subset_data, results = "hide"}
  saplings <- subset.ppp(hemlock_ppp, marks == "saplings", drop = TRUE)
  
  o_ring_saplings <- envelope(saplings, fun = Oest,
                              r = seq(from = 0, to = 45, by = 0.5), 
                              nsim = 199, nrank = 5)
```

```{r s_3_plot_subset, echo = FALSE, fig.align = "center"}
  plot(o_ring_saplings, xlim = c(0, 45), 
       main = "O-ring statistic\nsaplings", 
       legend = FALSE)
```

### Exercise 2 
__Task:__ Use the pair-correlation function to fit a cluster process to the data and use the fitted model to simulate null model data

We use the function `kkpm()` to fit a cluster point process model. We need to provide the point pattern (`X`, here we need to remove all marks with `unmark()` because `subset.ppp()` only drops all unused levels, but does not remove all marks). We specify the cluster type we want to fit (`cluster`) and which summary function to use (`pcf`). Then, we simulate patterns using the fitted process with `simulate.kppm()`. We need to provide the model (`object`) and the number of simulations (`nsim`). The result is a list of simulated patterns.

```{r s_3_thomas, results = "hide", warning = FALSE}
  thomas_process <- kppm(X = unmark(saplings), clusters = "Thomas", 
                         statistic = "pcf")
  
  simulated_pattern	<- simulate.kppm(object = thomas_process, nsim = 199)
```

Now, we can compute the envelopes of the null model and compare it to the observed data.

```{r s_3_envelopes_thomas, results = "hide"}  
  o22_saplings_thomas <- envelope(saplings, fun = Oest, 
                                  r = seq(from = 0, to = 45, by = 0.5),
                                  nsim = 199, nrank = 5, 
                                  simulate = simulated_pattern)
```

```{r s_3_plot_thomas, echo = FALSE, fig.align = "center"}
  plot(o22_saplings_thomas, xlim = c(0, 45), 
       main = "Hemlock saplings\nThomas process", legend = FALSE)
```

### Exercise 3
__Task:__ If the function of the observed data falls into the new envelope, you fitted good parameters for the cluster process. You can review them by inspecting the object. Here, the typical cluster size and number of parents are given.

`kappa` is the intensity of cluster centers. In order to get the 'number of parents', we need to multiply the number with the area of the observation window (remember: the intensity is the number per unit area). Luckily, `spatstat` contains a function (`area()`) to calculate the area. The `scale` parameter gives the standard deviation of random displacement of a point from its cluster center. To calculate the area of a cluster, we need to calculate the area of the according 'circle'. The `Mean cluster size` gives exactly what it says.

```{r s_3_model_parameter, collapse = TRUE}
  print(thomas_process)
```
  
```{r s_3_no_parents, echo = FALSE, collapse = TRUE}
  # Check with Programita!
  paste0("Number of parents: ", 
         round(thomas_process$clustpar[["kappa"]] * area(saplings$window), 2))

  paste0("Cluster area: ", 
         round((thomas_process$clustpar[["scale"]] ^ 2) * pi, 2))
```

# Mark correlation function (Stoyan's $k_{mm}$)

### Exercise 1 
__Task:__ The data set *Alive_DouglasFir_OGN.txt* contains the location and stem diameters (diameter at breast height, DBH) for all living Douglas fir trees in the Old-growth North plot. Calculate the mark correlation function. What do these results suggest?

First, we need to import the data, convert them as `ppp` object and have a look at the data. This time, the marks are continuous, i.e. the diameter at breast height in cm of each tree. Therefore, the `summary()` function automatically gives the mean, median and quantiles of the data. Also, the plot automatically scales the point according to their size. 

```{r s_3_import_snd_data, message = FALSE, collapse = TRUE}
  douglas_fir <- read_delim(file = "Data/Alive_DouglasFir_OGN.txt", 
                            delim = ";")
  
  plot_area <- ripras(x = douglas_fir$x, y = douglas_fir$y, 
                      shape = "rectangle")
  
  douglas_fir_ppp <- as.ppp(X = douglas_fir, W = plot_area)
  
  summary(douglas_fir_ppp)
```

```{r s_3_plot_snd_data, echo = FALSE, fig.align = "center"}
  plot(douglas_fir_ppp, main = "Douglas fir")
```

The mark-correlation function can be calculated with `markcorr()`. This is very straightforward.

```{r s_3_mark_correlation}
  mark_corrlation_douglas_fir <- markcorr(X = douglas_fir_ppp, 
                                          r = seq(from = 0, to = 45,
                                                  by = 0.5),
                                          correction = "Ripley")
```

```{r s_3_plot_mark_correlation, echo = FALSE, fig.align = "center"}
  plot(mark_corrlation_douglas_fir, xlim = c(0, 45), 
       main = "Mark correlation function\nDouglas fir", 
       legend = FALSE)
```

### Exercise 2 
__Task:__ Check Calculate simulation envelopes to test for significance. What could be a possible ecological explanation of your results?

We use `envelope()` to calculate the simulation envelopes. As null model, we use random labeling, shuffling only the marks but not the points (`simulate` argument using `rlabel()`).

```{r s_3_envelopes_mark_correlation, results = "hide"}
  envelopes_mark_correlation_alive <- envelope(Y = douglas_fir_ppp, 
                                               fun = markcorr,
                                               r = seq(from = 0, to = 45, 
                                                       by = 0.5),
                                               nsim = 199, nrank = 5,
                                               simulate = expression(rlabel(douglas_fir_ppp)))
```

```{r s_3_plot_envelopes_mark_correlation, echo = FALSE, fig.align = "center"}
  plot(envelopes_mark_correlation_alive, xlim = c(0, 45), 
       main = "Mark correlation function\nDouglas fir", 
       legend = FALSE)
```

# Inhomogeneous point patterns 

### Exercise 1 
__Task:__ In the data set *Hemlock_Adults_vs_SmallSaps.txt*, you can observe a clear gradient in the density of adult trees. Calculate O11(r) and L11(r) for pattern 1 (adult trees) to see up to which scale clustering of the trees can be observed using 'CSR' as null model.

We import the data, classify it and convert it as `ppp` object. We plot the point pattern of only adult trees and have a look at the summary.

```{r s_3_import_trd_data, message = FALSE, collapse = TRUE}
  hemlock <- read_delim(file = "Data/Hemlock_Adults_vs_SmallSaps.txt", 
                        delim = ";")
  
  hemlock <- mutate(hemlock,
                    mark = case_when(mark == 1 ~ "adults",
                                     mark == 2 ~ "saplings"),
                    mark = as.factor(mark))
  
  plot_area <- ripras(x = hemlock$x, y = hemlock$y, 
                      shape = "rectangle")
  
  hemlock_ppp <- as.ppp(X = hemlock, W = plot_area)
  
  summary(hemlock_ppp)
```

```{r s_3_plot_trd_data , echo = FALSE, fig.align = "center"}
  plot(subset.ppp(hemlock_ppp, marks == "adults", drop = TRUE), 
       main = "Hemlock \nadults")
```

Also, we need to implement the O-ring statistic as before.

```{r s_3_define_fun_new}
  Oest <- function(input,r = NULL,
                   correction = "Ripley", divisor = "d", ...){
    
    p_fct <- pcf(input,  r = r,
                 correction = correction, divisor = divisor, ...)
    
    lambda <- intensity(unmark(input))
    
    eval.fv(p_fct*lambda)
  }
``` 

We calculate the O-ring statistic for the adult trees only, using `envelope()` and the null model of 'CSR'. 

```{r s_3_oring_adults, results = "hide"}
  adults <- subset.ppp(hemlock_ppp, marks == "adults", drop = TRUE)
  
  envelopes_adults_homo <- envelope(Y = adults, fun = Oest,
                                    r = seq(from = 0, to = 45, by = 0.5), 
                                    nsim = 199, rank = 5)
```

```{r s_3_plot_oring_adults, echo = FALSE, fig.align = "center"}
  plot(envelopes_adults_homo, xlim = c(0,45), 
       main = "Homogenous Poisson process")
```

### Exercise 2 
__Task:__ Getzin et al. (2008) show that the study area is heterogeneous. We are going to account for this heterogeneity by fitting a heterogeneous Poisson processes.

Firstly, we need to get the intensity $\lambda(xy)$ at every point of the observation window. The result is a `im` (pixel image) object. 

```{r s_3_lambda, collapse = TRUE}
  lambda_xy <- density(x = adults)

  class(lambda_xy)
```

```{r s_3_plot_lambda, echo = FALSE, fig.align = "center"}
  plot(lambda_xy, main = "lambda(xy)")
```

Now, we can simulate heterogeneous point patterns following the intensity of the pattern. Therefore, we use `rpoispp()` and specify the argument `lambda` with the created `im` object. Also, we specify the number of simulated patterns (`nsim`). The result is a list with heterogeneous point patterns. If you plot one realization of the simulated data, you can see how the random points 'follow' the intensity.

```{r s_3_simul_hetero}
  simulated_heterogenous_pattern <- rpoispp(lambda = lambda_xy, nsim = 199)
```

```{r s_3_plot_hetero, echo = FALSE, fig.align = "center"}
  plot(lambda_xy, main = "Simulated data")

  points(simulated_heterogenous_pattern[[5]], pch = 19)
``` 

Now, we can use the simulated point patterns as input for `envelope()` to create simulation envelopes with the null model of a heterogeneous Poisson process.

```{r s_3_envelopes_hetero, results = "hide"}
  envelopes_adults_hetero <- envelope(Y = adults, fun = Oest,
                                      r = seq(from = 0, to = 45, 
                                              by = 0.5), 
                                      nsim = 199, rank = 5, 
                                      simulate = simulated_heterogenous_pattern)

```

```{r s_3_plot_sim_hetero, echo = FALSE, fig.align = "center"}
  plot(envelopes_adults_hetero, xlim = c(0, 45), 
       main = "Heterogenous Poisson process")
```

There is a wrapper around these function in [`onpoint`](https://r-spatialecology.github.io/onpoint/) to simulate a heterogenous Poisson process as null model (see `?simulate_heterogenous_pattern`).

Alternativly, `spatstat` can calculated the inhomogenous pair-correlation function and consider the heterogneous plot conditions while estimating the pair-correlation function.

```{r s_3_envelopes_inhomo, results = "hide"}
  envelopes_adults_inhomo <- envelope(Y = adults, fun = pcfinhom, 
                                      divisor = "d",
                                      correction = "Ripley",
                                      r = seq(from = 0, to = 45, by = 0.5),
                                      nsim = 199, rank = 5)
```

```{r s_3_plot_envelopes_hetero, echo = FALSE, fig.align = "center"}
  plot(envelopes_adults_inhomo, xlim = c(0,45),
       main = "Inhomogenous pair correlation function",
       legend = FALSE)
```

__References__:

Baddeley, A., Rubak, E., Turner, R., 2015. Spatial point patterns: Methodology and applications with R. Chapman and Hall/CRC Press, London.

Getzin, S., Dean, C., He, F., Trofymow, J.A., Wiegand, K., Wiegand, T., 2006. Spatial patterns and competition of tree species in a Douglas fir chronosequence on Vancouver Island. Ecography, 29, 671-682.

Getzin, S., Wiegand, T., Wiegand, K., He, F., 2008. Heterogeneity influences spatial patterns and demographics in forest stands. J. Ecol. 96, 807-820.